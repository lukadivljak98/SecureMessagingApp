package net.etfbl.crypto;

import java.nio.charset.StandardCharsets;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyAgreement;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class CryptoUtil {
	
	private static SecretKey secret;
	
	public static String getHash(String input) {
		 StringBuilder hexString = new StringBuilder();
		 try {
	        MessageDigest md = MessageDigest.getInstance("SHA-256");
	        byte[] hash = md.digest(input.getBytes(StandardCharsets.UTF_8));
	        hexString = new StringBuilder();
	        for (byte b : hash) {
	            String hex = Integer.toHexString(0xff & b);
	            if (hex.length() == 1) {
	                hexString.append('0');
	            }
	            hexString.append(hex);
	        }
	        
		 }catch(NoSuchAlgorithmException e) {
			 
		 }
		 return hexString.toString();
	}
	
	public static void generateSharedSecret(String recipientPublicKeyBase64, String encryptedSenderPrivateKeyBase64, String masterKeyBase64) {
	    try {
	        byte[] masterKeyBytes = Base64.getDecoder().decode(masterKeyBase64);
	        SecretKey masterKey = new SecretKeySpec(masterKeyBytes, "AES");

	        byte[] encryptedSenderPrivateKeyBytes = Base64.getDecoder().decode(encryptedSenderPrivateKeyBase64);
	        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
	        IvParameterSpec ivParameterSpec = new IvParameterSpec(new byte[16]);
	        cipher.init(Cipher.DECRYPT_MODE, masterKey, ivParameterSpec);
	        byte[] senderPrivateKeyBytes = cipher.doFinal(encryptedSenderPrivateKeyBytes);

	        byte[] recipientPublicKeyBytes = Base64.getDecoder().decode(recipientPublicKeyBase64);
	        KeyFactory keyFactory = KeyFactory.getInstance("DH");
	        PublicKey recipientPublicKey = keyFactory.generatePublic(new X509EncodedKeySpec(recipientPublicKeyBytes));
	        PrivateKey senderPrivateKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(senderPrivateKeyBytes));
	        KeyAgreement keyAgreement = KeyAgreement.getInstance("DH");
	        keyAgreement.init(senderPrivateKey);
	        keyAgreement.doPhase(recipientPublicKey, true);
	        byte[] sharedSecretBytes = keyAgreement.generateSecret();
	        SecretKey sharedSecret = new SecretKeySpec(sharedSecretBytes, 0, 16, "AES");

	        secret = sharedSecret;

	    } catch (NoSuchAlgorithmException | InvalidKeySpecException | InvalidKeyException | NoSuchPaddingException | BadPaddingException | IllegalBlockSizeException | InvalidAlgorithmParameterException e) {
	        e.printStackTrace();
	    }
	}
	
	public static String encryptSegmentText(String segmentText) {
	    try {
	        // Create an instance of the AES cipher
	        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

	        // Generate a random initialization vector (IV)
	        SecureRandom secureRandom = new SecureRandom();
	        byte[] iv = new byte[16];
	        secureRandom.nextBytes(iv);
	        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

	        // Initialize the cipher with the shared secret and IV for encryption
	        cipher.init(Cipher.ENCRYPT_MODE, secret, ivParameterSpec);

	        // Encrypt the segment text
	        byte[] plaintextBytes = segmentText.getBytes(StandardCharsets.UTF_8);
	        byte[] encryptedBytes = cipher.doFinal(plaintextBytes);

	        // Combine the IV and the encrypted bytes
	        byte[] combinedBytes = new byte[iv.length + encryptedBytes.length];
	        System.arraycopy(iv, 0, combinedBytes, 0, iv.length);
	        System.arraycopy(encryptedBytes, 0, combinedBytes, iv.length, encryptedBytes.length);

	        // Encode the result in Base64
	        String encryptedSegmentTextBase64 = Base64.getEncoder().encodeToString(combinedBytes);

	        return encryptedSegmentTextBase64;
	    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException | InvalidAlgorithmParameterException e) {
	        e.printStackTrace();
	    }

	    return null;
	}

	public static SecretKey getSecret() {
		return secret;
	}

	public static void setSecret(SecretKey secret) {
		CryptoUtil.secret = secret;
	}
	
}
