package net.etfbl.crypto;

import java.nio.charset.StandardCharsets;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyAgreement;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class CryptoUtil {
	
	public static String getHash(String input) {
		 StringBuilder hexString = new StringBuilder();
		 try {
	        MessageDigest md = MessageDigest.getInstance("SHA-256");
	        byte[] hash = md.digest(input.getBytes(StandardCharsets.UTF_8));
	        hexString = new StringBuilder();
	        for (byte b : hash) {
	            String hex = Integer.toHexString(0xff & b);
	            if (hex.length() == 1) {
	                hexString.append('0');
	            }
	            hexString.append(hex);
	        }
	        
		 }catch(NoSuchAlgorithmException e) {
			 
		 }
		 return hexString.toString();
	}
	
	public static SecretKey generateSharedSecret(String recipientPublicKeyBase64, String encryptedSenderPrivateKeyBase64, String masterKeyBase64) {
	    try {
	        // Decode master key from Base64
	        byte[] masterKeyBytes = Base64.getDecoder().decode(masterKeyBase64);
	        SecretKey masterKey = new SecretKeySpec(masterKeyBytes, "AES");

	        // Decrypt the sender's private key using the master key
	        byte[] encryptedSenderPrivateKeyBytes = Base64.getDecoder().decode(encryptedSenderPrivateKeyBase64);
	        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
	        IvParameterSpec ivParameterSpec = new IvParameterSpec(new byte[16]);
	        cipher.init(Cipher.DECRYPT_MODE, masterKey, ivParameterSpec);
	        byte[] senderPrivateKeyBytes = cipher.doFinal(encryptedSenderPrivateKeyBytes);

	        // Follow the previous steps to generate the shared secret
	        byte[] recipientPublicKeyBytes = Base64.getDecoder().decode(recipientPublicKeyBase64);
	        KeyFactory keyFactory = KeyFactory.getInstance("DH");
	        PublicKey recipientPublicKey = keyFactory.generatePublic(new X509EncodedKeySpec(recipientPublicKeyBytes));
	        PrivateKey senderPrivateKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(senderPrivateKeyBytes));
	        KeyAgreement keyAgreement = KeyAgreement.getInstance("DH");
	        keyAgreement.init(senderPrivateKey);
	        keyAgreement.doPhase(recipientPublicKey, true);
	        byte[] sharedSecretBytes = keyAgreement.generateSecret();
	        SecretKey sharedSecret = new SecretKeySpec(sharedSecretBytes, 0, 16, "AES");

	        return sharedSecret;

	    } catch (NoSuchAlgorithmException | InvalidKeySpecException | InvalidKeyException | NoSuchPaddingException | BadPaddingException | IllegalBlockSizeException | InvalidAlgorithmParameterException e) {
	        e.printStackTrace();
	    }

	    return null;
	}
}
